require File.expand_path('../../lib/gpx', __FILE__)
require 'optparse'

=begin
class GPX::TrackPoint < GPX::Point
  attr_accessor :new_lat, :new_lon, :new_elevation

  def update_new_values
    self.lon = self.new_lon if self.new_lon
    self.lat = self.new_lat if self.new_lat
    self.elevation = self.new_elevation if self.new_elevation
  end
=end


=begin
class GPX::Segment < GPX::Base
  def find_point_by_time_or_offset(indicator)
    if indicator.nil?
      return nil
    elsif indicator.is_a?(Integer)
      return self.closest_point(self.earliest_point.time + indicator)
    elsif(indicator.is_a?(Time))
      return self.closest_point(indicator)
    else
      raise Exception, "find_end_point_by_time_or_offset requires an argument of type Time or Integer"
    end
  end

  def smooth_location_by_average(opts={})
    seconds_either_side = opts[:averaging_window] || 20
    earliest = (find_point_by_time_or_offset(opts[:start]) || self.earliest_point).time
    latest = (find_point_by_time_or_offset(opts[:end]) || self.latest_point).time
    self.points.each do |point|
      next if point.time > latest || point.time < earliest
      lat_av = 0.to_f
      lon_av = 0.to_f
      alt_av = 0.to_f
      n = 0
      (-1*seconds_either_side..seconds_either_side).each do |k|
        contributing_point = self.closest_point(point.time + k)
        lat_av += contributing_point.lat
        lon_av += contributing_point.lon
        alt_av += contributing_point.elevation
        n += 1
      end
      point.new_lon = (lon_av) / n
      point.new_elevation = (alt_av) / n
      point.new_lat = (lat_av) / n
    end
    last_pt = nil
    @distance = 0
    self.points.each do |point|
      if point.time <= latest || point.time >= earliest
        point.update_new_values
      end
      @distance += haversine_distance(last_pt, point) unless last_pt.nil?
      last_pt = point
    end
  end

end
=end

=begin
class GPX::Track < GPX::Base
  def recalculate_distance
    @distance = 0
    segments.each do |seg|
      @distance += seg.distance
    end
  end
end

class GPX::GPXFile < GPX::Base
  def recalculate_distance
    @distance = 0
    tracks.each do |track|
      track.recalculate_distance
      @distance += track.distance
    end
  end
end
=end


def str_to_int_or_time(str)
  if str =~ /\A\d{10}\Z/
    return Time.at(str.to_i)
  elsif str =~ /\A\d+\Z/
    return str.to_i
  else
    return DateTime.strptime(str, '%Y%m%d-%H:%M:%S').to_time
  end
end


options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: smooth [options]"

  opts.on("-i", "--input-file FILE", "Input file to read gpx data from (if omitted, data will be read from stdin)") do |v|
    options[:infile] = v
  end
  opts.on("-o", "--output-file FILE", "Output file to write smoothed gpx data to (if omitted, data will be written to stdout)") do |v|
    options[:outfile] = v
  end
  opts.on("-s", "--start-time [YYYYMMDD-HH:MM:SS|EPOCH|OFFSET]", "Start smoothing from time or offset specified (if omitted start from the start of the file)") do |v|
    options[:start] = v
  end
  opts.on("-e", "--end-time [YYYYMMDD-HH:MM:SS|EPOCH|OFFSET]", "Finish smoothing from time or offset specified (if omitted finish at the end of the file)") do |v|
    options[:end] = v
  end
end.parse!


if options[:infile]
  input = File.open(options[:infile])
else
  input = $stdin
end

options[:start] = str_to_int_or_time(options[:start]) if options[:start]
options[:end] = str_to_int_or_time(options[:end]) if options[:end]

gpx =  GPX::GPXFile.new(:gpx_data => input)
$stderr.puts "read track with distance #{gpx.distance}"

#1419062980
gpx.tracks.each do |track|
  track.segments.each do |segment|
    segment.smooth_location_by_average({:end => options[:end], :start => options[:start]})
  end
end
gpx.recalculate_distance
$stderr.puts "smoothed distance #{gpx.distance}"

if options[:outfile]
  gpx.write(options[:outfile], false)
else
  puts gpx.to_s(false)
end



